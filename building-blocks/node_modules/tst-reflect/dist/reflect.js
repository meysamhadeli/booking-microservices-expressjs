"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NativeTypes = exports.reflect = exports.getType = exports.getTypeOfRuntimeValue = void 0;
const FunctionBuilder_1 = require("./type-builder/FunctionBuilder");
const ObjectLiteralTypeBuilder_1 = require("./type-builder/ObjectLiteralTypeBuilder");
const TypeBuilder_1 = require("./type-builder/TypeBuilder");
const consts_1 = require("./consts");
const enums_1 = require("./enums");
const Type_1 = require("./Type");
const ArrayItemsCountToCheckItsType = 10;
/**
 * @param value
 * @internal
 */
function getTypeOfRuntimeValue(value) {
    var _a, _b;
    if (value === undefined)
        return Type_1.Type.Undefined;
    if (value === null)
        return Type_1.Type.Null;
    if (typeof value === "string")
        return Type_1.Type.String;
    if (typeof value === "number")
        return Type_1.Type.Number;
    if (typeof value === "boolean")
        return Type_1.Type.Boolean;
    if (value instanceof Date)
        return Type_1.Type.Date;
    if (value.constructor === Object)
        return ObjectLiteralTypeBuilder_1.ObjectLiteralTypeBuilder.fromObject(value);
    if (!value.constructor) {
        return Type_1.Type.Unknown;
    }
    if (value.constructor == Array) {
        const set = new Set();
        // If it is an array, there can be anything; we'll check first X cuz of performance.
        for (let item of value.slice(0, ArrayItemsCountToCheckItsType)) {
            set.add(getTypeOfRuntimeValue(item));
        }
        const valuesTypes = Array.from(set);
        const arrayBuilder = TypeBuilder_1.TypeBuilder.createArray();
        if (value.length == 0) {
            return arrayBuilder
                .setGenericType(Type_1.Type.Any)
                .build();
        }
        const unionBuilder = TypeBuilder_1.TypeBuilder.createUnion(valuesTypes);
        // If there are more items than we checked, add Unknown type to the union.
        if (value.length > ArrayItemsCountToCheckItsType) {
            unionBuilder.addTypes(Type_1.Type.Unknown);
        }
        return arrayBuilder.setGenericType(unionBuilder.build()).build();
    }
    if (typeof value === "function" && (value.prototype == undefined || ((_a = Object.getOwnPropertyDescriptor(value, "prototype")) === null || _a === void 0 ? void 0 : _a.writable) === true)) {
        return FunctionBuilder_1.FunctionBuilder.fromFunction(value);
    }
    return Type_1.Type.store.get((typeof value === "function" && ((_b = value.prototype) === null || _b === void 0 ? void 0 : _b[consts_1.REFLECTED_TYPE_ID]))
        || value.constructor.prototype[consts_1.REFLECTED_TYPE_ID]) || Type_1.Type.Unknown;
}
exports.getTypeOfRuntimeValue = getTypeOfRuntimeValue;
function getType(...args) {
    if (args.length) {
        return getTypeOfRuntimeValue(args[0]);
    }
    if (!((typeof window === "object" && window) || (typeof global === "object" && global) || globalThis)["tst-reflect-disable"]) {
        console.debug("[ERR] tst-reflect: You call getType() method directly. " +
            "You have probably wrong configuration, because tst-reflect-transformer package should replace this call by the Type instance.\n" +
            "If you have right configuration it may be BUG so try to create an issue.\n" +
            "If it is not an issue and you don't want to see this debug message, " +
            "create field 'tst-reflect-disable' in global object (window | global | globalThis) eg. `window['tst-reflect-disable'] = true;`");
    }
    // In case of direct call, we'll return Unknown type.
    return Type_1.Type.Unknown;
}
exports.getType = getType;
/** @internal */
getType.__tst_reflect__ = true;
/**
 * Class decorator which marks classes to be processed and included in metadata lib file.
 * @reflect
 */
function reflect() {
    return function (Constructor) {
        return Constructor;
    };
}
exports.reflect = reflect;
reflect.__tst_reflect__ = true;
function createNativeType(typeName, ctor) {
    const type = Reflect.construct(Type_1.Type, [], Type_1.TypeActivator);
    type.initialize({
        n: typeName,
        fn: typeName,
        ctor: () => ctor,
        k: enums_1.TypeKind.Native
    });
    return type;
}
const objectNativeType = createNativeType("Object", Object);
Type_1.Type.Object = objectNativeType;
/**
 * List of native types
 * @description It should save some memory and all native Types will be the same instances.
 */
const nativeTypes = {
    "Object": objectNativeType,
    "Unknown": createNativeType("unknown"),
    "Any": createNativeType("any"),
    "Void": createNativeType("void"),
    "String": createNativeType("String", String),
    "Number": createNativeType("Number", Number),
    "Boolean": createNativeType("Boolean", Boolean),
    "Date": createNativeType("Date", Date),
    "Null": createNativeType("null"),
    "Undefined": createNativeType("undefined"),
    "Never": createNativeType("never"),
    "BigInt": createNativeType("BigInt"),
};
/**
 * @internal
 */
exports.NativeTypes = new Map();
for (let entry of Object.entries(nativeTypes)) {
    exports.NativeTypes.set(entry[0].toLowerCase(), entry[1]);
}
for (const typeName in nativeTypes) {
    if (nativeTypes.hasOwnProperty(typeName)) {
        Type_1.Type[typeName] = nativeTypes[typeName];
    }
}
