"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccessModifier = exports.Accessor = exports.TypeKind = void 0;
/**
 * Kind of type
 */
var TypeKind;
(function (TypeKind) {
    /**
     * Interface
     */
    TypeKind[TypeKind["Interface"] = 0] = "Interface";
    /**
     * Class
     */
    TypeKind[TypeKind["Class"] = 1] = "Class";
    /**
     * Native JavaScript/TypeScript type
     */
    TypeKind[TypeKind["Native"] = 2] = "Native";
    /**
     * Container for other types in case of types union or intersection
     */
    TypeKind[TypeKind["Container"] = 3] = "Container";
    /**
     * Type reference created during type checking
     * @description Usually Array<...>, ReadOnly<...> etc.
     */
    TypeKind[TypeKind["TransientTypeReference"] = 4] = "TransientTypeReference";
    /**
     * Some specific object
     * @description Eg. "{ foo: string, bar: boolean }"
     */
    TypeKind[TypeKind["Object"] = 5] = "Object";
    /**
     * Some subtype of string, number, boolean
     * @example <caption>type Foo = "hello world" | "hello"</caption>
     * String "hello world" is literal type and it is subtype of string.
     *
     * <caption>type TheOnlyTrue = true;</caption>
     * Same as true is literal type and it is subtype of boolean.
     */
    TypeKind[TypeKind["LiteralType"] = 6] = "LiteralType";
    /**
     * Fixed lenght arrays literals
     * @example <caption>type Coords = [x: number, y: number, z: number];</caption>
     */
    TypeKind[TypeKind["Tuple"] = 7] = "Tuple";
    /**
     * Generic parameter type
     * @description Represent generic type parameter of generic types. Eg. it is TType of class Animal<TType> {}.
     */
    TypeKind[TypeKind["TypeParameter"] = 8] = "TypeParameter";
    /**
     * Conditional type
     */
    TypeKind[TypeKind["ConditionalType"] = 9] = "ConditionalType";
    /**
     * Indexed access type
     * @description Eg. get<K extends keyof TypeKind>(key: K): ==>> TypeKind[K] <<==
     */
    TypeKind[TypeKind["IndexedAccess"] = 10] = "IndexedAccess";
    /**
     * Typescript "module"
     * @description Value module or namespace module
     */
    TypeKind[TypeKind["Module"] = 11] = "Module";
    /**
     * Specific method used as type
     */
    TypeKind[TypeKind["Method"] = 12] = "Method";
    /**
     * Enum
     */
    TypeKind[TypeKind["Enum"] = 13] = "Enum";
    /**
     * function foo() {}
     */
    TypeKind[TypeKind["Function"] = 14] = "Function";
})(TypeKind = exports.TypeKind || (exports.TypeKind = {}));
var Accessor;
(function (Accessor) {
    Accessor[Accessor["None"] = 0] = "None";
    Accessor[Accessor["Getter"] = 1] = "Getter";
    Accessor[Accessor["Setter"] = 2] = "Setter";
})(Accessor = exports.Accessor || (exports.Accessor = {}));
var AccessModifier;
(function (AccessModifier) {
    AccessModifier[AccessModifier["Private"] = 0] = "Private";
    AccessModifier[AccessModifier["Protected"] = 1] = "Protected";
    AccessModifier[AccessModifier["Public"] = 2] = "Public";
})(AccessModifier = exports.AccessModifier || (exports.AccessModifier = {}));
