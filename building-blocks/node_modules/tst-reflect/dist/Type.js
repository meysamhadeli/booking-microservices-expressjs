"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypeActivator = exports.Type = exports.LazyType = void 0;
const function_type_1 = require("./descriptions/function-type");
const indexed_access_type_1 = require("./descriptions/indexed-access-type");
const conditional_type_1 = require("./descriptions/conditional-type");
const constructor_import_1 = require("./descriptions/constructor-import");
const enums_1 = require("./enums");
const mapper_1 = require("./mapper");
const flatten_1 = require("./flatten");
class LazyType {
    constructor(type) {
        if (typeof type === "function") {
            this.typeResolver = type.name === "lazyType" ? type : () => Type.Unknown;
        }
        else {
            this.typeResolver = () => Type.Undefined;
            this.resolvedType = type;
        }
    }
    get type() {
        var _a;
        return (_a = this.resolvedType) !== null && _a !== void 0 ? _a : (this.resolvedType = this.typeResolver());
    }
}
exports.LazyType = LazyType;
/**
 * Object representing TypeScript type in memory
 */
class Type {
    /**
     * Internal Type constructor
     * @internal
     */
    constructor() {
        if (new.target != TypeActivator) {
            throw new Error("You cannot create instance of Type manually!");
        }
    }
    /**
     * @internal
     * @param {TypeProperties} description
     */
    initialize(description) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        this._name = description.n || "";
        this._fullName = description.fn || description.n || "";
        this._kind = description.k;
        this._constructors = ((_a = description.ctors) === null || _a === void 0 ? void 0 : _a.map(mapper_1.Mapper.mapConstructors)) || [];
        this._properties = ((_b = description.props) === null || _b === void 0 ? void 0 : _b.map(mapper_1.Mapper.mapProperties)) || [];
        this._indexes = ((_c = description.indxs) === null || _c === void 0 ? void 0 : _c.map(mapper_1.Mapper.mapIndexes)) || [];
        this._methods = ((_d = description.meths) === null || _d === void 0 ? void 0 : _d.map(mapper_1.Mapper.mapMethods)) || [];
        this._decorators = ((_e = description.decs) === null || _e === void 0 ? void 0 : _e.map(mapper_1.Mapper.mapDecorators)) || [];
        this._typeParameters = ((_f = description.tp) === null || _f === void 0 ? void 0 : _f.map(t => new LazyType(t))) || [];
        this._ctor = description.ctor;
        this._ctorDesc = Reflect.construct(constructor_import_1.ConstructorImport, [description.ctorDesc], constructor_import_1.ConstructorImportActivator);
        this._interface = description.iface ? new LazyType(description.iface) : undefined;
        this._isUnion = description.union || false;
        this._isIntersection = description.inter || false;
        this._types = ((_g = description.types) === null || _g === void 0 ? void 0 : _g.map(t => new LazyType(t))) || [];
        this._literalValue = description.v;
        this._typeArgs = ((_h = description.args) === null || _h === void 0 ? void 0 : _h.map(t => new LazyType(t))) || [];
        this._conditionalType = description.ct ? new conditional_type_1.ConditionalType(description.ct) : undefined;
        this._indexedAccessType = description.iat ? new indexed_access_type_1.IndexedAccessType(description.iat) : undefined;
        this._functionSignatures = (_k = (_j = description.sg) === null || _j === void 0 ? void 0 : _j.map(signature => new function_type_1.FunctionInfo(signature))) !== null && _k !== void 0 ? _k : [];
        this._genericTypeConstraint = description.con ? new LazyType(description.con) : undefined;
        this._genericTypeDefault = description.def ? new LazyType(description.def) : undefined;
        this._isGenericType = description.isg ? description.isg : false;
        this._genericTypeDefinition = description.gtd ? new LazyType(description.gtd) : undefined;
        // BaseType of Type.Object must be undefined
        this._baseType = description.bt
            ? new LazyType(description.bt)
            : (this.isNative() && this.name === "Object" && (!description.props || !description.props.length)
                ? undefined
                : new LazyType(Type.Object));
    }
    /**
     * Returns information about generic conditional type.
     */
    get condition() {
        return this._conditionalType;
    }
    /**
     * Returns information about indexed access type.
     */
    get indexedAccessType() {
        return this._indexedAccessType;
    }
    /**
     * List of underlying types in case Type is union or intersection
     */
    get types() {
        return this._types.map(t => t.type);
    }
    /**
     * Get meta for the module of the defined constructor
     * This data is not set when the config mode is set to "universal"
     */
    get constructorDescription() {
        return this._ctorDesc || undefined;
    }
    /**
     * Get definition of a generic type.
     */
    get genericTypeDefinition() {
        var _a;
        return (_a = this._genericTypeDefinition) === null || _a === void 0 ? void 0 : _a.type;
    }
    /**
     * Base type
     * @description Base type from which this type extends from or undefined if type is Object.
     */
    get baseType() {
        var _a;
        return (_a = this._baseType) === null || _a === void 0 ? void 0 : _a.type;
    }
    /**
     * Interface which this type implements
     */
    get interface() {
        var _a;
        return (_a = this._interface) === null || _a === void 0 ? void 0 : _a.type;
    }
    /**
     * Get type full-name
     * @description Contains file path base to project root
     */
    get fullName() {
        return this._fullName;
    }
    /**
     * Get type name
     */
    get name() {
        return this._name;
    }
    /**
     * Get kind of type
     */
    get kind() {
        return this._kind;
    }
    /**
     * Underlying value in case of literal type
     */
    get literalValue() {
        return this._literalValue;
    }
    /**
     * Generic type constrains
     */
    get genericTypeConstraint() {
        var _a;
        return (_a = this._genericTypeConstraint) === null || _a === void 0 ? void 0 : _a.type;
    }
    /**
     * Generic type default value
     */
    get genericTypeDefault() {
        return this._genericTypeDefault;
    }
    /**
     * Search the type store for a specific type
     *
     * Runs the provided filter callback on each type. If your filter returns true, it returns this type.
     *
     * @param {(type: Type) => boolean} filter
     * @returns {Type | undefined}
     */
    static find(filter) {
        for (let storeKey in this._store.store) {
            if (filter(this._store.store[storeKey])) {
                return this._store.store[storeKey];
            }
        }
        return undefined;
    }
    /**
     * Returns all Types contained in metadata.
     * This method is quite useless with reflection.metadata.type = "inline"; Use "typelib" type.
     */
    static getTypes() {
        return Object.values(this._store.store);
    }
    static get store() {
        return this._store;
    }
    /** @internal */
    static _setStore(store) {
        this._store = store;
    }
    /**
     * Returns true if types are equals
     * @param type
     */
    is(type) {
        if (this == Type.Unknown) {
            return false;
        }
        return type != undefined && this._fullName == type._fullName && !!this._fullName;
    }
    /**
     * Returns a value indicating whether the Type is container for unified Types or not
     */
    isUnion() {
        return this._isUnion;
    }
    /**
     * Returns a value indicating whether the Type is container for intersecting Types or not
     */
    isIntersection() {
        return this._isIntersection;
    }
    /**
     * Returns true whether current Type is a class with any constructor.
     */
    isInstantiable() {
        var _a;
        return !!((_a = this.getConstructors()) === null || _a === void 0 ? void 0 : _a.length);
    }
    /**
     * Returns a value indicating whether the Type is a class or not
     */
    isClass() {
        return this.kind == enums_1.TypeKind.Class;
    }
    /**
     * Returns a value indicating whether the Type is a interface or not
     */
    isInterface() {
        return this.kind == enums_1.TypeKind.Interface;
    }
    /**
     * Returns a value indicating whether the Type is an literal or not
     */
    isLiteral() {
        return this._kind == enums_1.TypeKind.LiteralType;
    }
    /**
     * Returns a value indicating whether the Type is an object literal or not
     */
    isObjectLiteral() {
        return this._kind == enums_1.TypeKind.Object;
    }
    /**
     * Returns true if type is union or intersection of types
     */
    isUnionOrIntersection() {
        return this.isUnion() || this.isIntersection();
    }
    /**
     * Check if this is a native type ("string", "number", "boolean", "Array" etc.)
     */
    isNative() {
        return this.kind === enums_1.TypeKind.Native;
    }
    /**
     * Check whether the type is generic.
     */
    isGenericType() {
        return this._isGenericType;
    }
    /**
     * Check if this is a primitive type ("string", "number", "boolean" etc.)
     */
    isPrimitive() {
        return this.kind === enums_1.TypeKind.Native && (this == Type.String
            || this == Type.Number
            || this == Type.BigInt
            || this == Type.Undefined
            || this == Type.Null
            || this == Type.Void
            || this == Type.Boolean
            || this == Type.Never);
    }
    /**
     * Check if this type is a string
     */
    isString() {
        return (this.isNative() || this.kind == enums_1.TypeKind.LiteralType) && this.name.toLowerCase() == "string";
    }
    /**
     * Check if this type is a number
     */
    isNumber() {
        return (this.isNative() || this.kind == enums_1.TypeKind.LiteralType) && this.name.toLowerCase() == "number";
    }
    /**
     * Check if this type is a symbol
     */
    isSymbol() {
        return this.isNative() && this.name.toLowerCase() == "symbol";
    }
    /**
     * Check if this type is a boolean
     */
    isBoolean() {
        return (this.isNative() || this.kind == enums_1.TypeKind.LiteralType) && this.name.toLowerCase() == "boolean";
    }
    /**
     * Check if this type is an array
     */
    isArray() {
        return (this.isNative() || this.kind == enums_1.TypeKind.LiteralType || this.kind == enums_1.TypeKind.TransientTypeReference) && (this.name == "Array" || this.name == "ReadonlyArray");
    }
    /**
     * Check if this type is a promise
     */
    isPromise() {
        return this.isNative() && this.name == "Promise";
    }
    /**
     * Check if this type is a Tuple
     */
    isTuple() {
        return this.kind == enums_1.TypeKind.Tuple;
    }
    /**
     * Check if this type is an any
     */
    isAny() {
        return this.isNative() && this.name == "any";
    }
    /**
     * Check if this type is a "unknown".
     */
    isUnknown() {
        return this.isNative() && this.name == "unknown";
    }
    /**
     * Check if this type is a "undefined" literal.
     */
    isUndefined() {
        return this.isNative() && this.name == "undefined";
    }
    /**
     * Check if this type is a "null" literal.
     */
    isNull() {
        return this.isNative() && this.name == "null";
    }
    /**
     * Check if this type is a "true" literal.
     */
    isTrue() {
        return this.isNative() && this.name == "true";
    }
    /**
     * Check if this type is a "false" literal.
     */
    isFalse() {
        return this.isNative() && this.name == "false";
    }
    /**
     *
     * @return {boolean}
     */
    isObjectLike() {
        return this.isObjectLiteral() || this.isClass() || this.isInterface();
    }
    /**
     * Determines whether the object represented by the current Type is an Enum.
     * @return {boolean}
     */
    isEnum() {
        return this.kind == enums_1.TypeKind.Enum;
    }
    /**
     * Returns information about the enumerable elements.
     */
    getEnum() {
        var _a;
        if (!this.isEnum()) {
            return undefined;
        }
        const entries = ((_a = this.types) === null || _a === void 0 ? void 0 : _a.map(type => Object.freeze([type.name, type.literalValue]))) || [];
        return {
            getValues() {
                return entries.map(entry => entry[1]);
            },
            getEntries() {
                return entries.slice();
            },
            getEnumerators() {
                return entries.map(entry => entry[0]);
            }
        };
    }
    /**
     * Constructor function in case Type is class
     */
    getCtor() {
        var _a, _b;
        return (_b = (_a = this._ctor) === null || _a === void 0 ? void 0 : _a.call(this)) !== null && _b !== void 0 ? _b : Promise.resolve(undefined);
    }
    /**
     * Returns array of function call signatures.
     */
    getSignatures() {
        return this._functionSignatures.slice();
    }
    /**
     * Returns array of type parameters.
     */
    getTypeParameters() {
        return this._typeParameters.map(t => t.type);
    }
    /**
     * Returns type arguments in case of generic type
     */
    getTypeArguments() {
        return this._typeArgs.map(t => t.type);
    }
    /**
     * Returns constructor description when Type is a class
     */
    getConstructors() {
        if (!this.isClass()) {
            return undefined;
        }
        return this._constructors.slice();
    }
    /**
     * Returns array of properties
     */
    getProperties() {
        return this._properties.slice();
    }
    /**
     * Returns array of indexes
     */
    getIndexes() {
        return this._indexes.slice();
    }
    /**
     * Returns array of methods
     */
    getMethods() {
        return this._methods.slice();
    }
    /**
     * Returns array of decorators
     */
    getDecorators() {
        return this._decorators.slice();
    }
    /**
     * Returns object with all methods and properties from current Type and all methods and properties inherited from base types and interfaces to this Type.
     * @return {{properties: {[p: string]: PropertyInfo}, methods: {[p: string]: MethodInfo}}}
     */
    flattenInheritedMembers() {
        return flatten_1.flatten(this);
    }
    /**
     * Determines whether the class represented by the current Type derives from the class represented by the specified Type
     * @param {Type} classType
     */
    isSubclassOf(classType) {
        if (!classType.isClass()) {
            // throw new Error("Argument 'classType' must be Type representing a class.");
            return false;
        }
        return this.isClass() && !!this.baseType && (this.baseType.is(classType) || this.baseType.isSubclassOf(classType));
    }
    /**
     * Determines whether the current Type derives from the specified Type
     * @param {Type} targetType
     */
    isDerivedFrom(targetType) {
        var _a, _b;
        return this.is(targetType)
            || ((_a = this.baseType) === null || _a === void 0 ? void 0 : _a.isAssignableTo(targetType))
            || ((_b = this.interface) === null || _b === void 0 ? void 0 : _b.isAssignableTo(targetType))
            || false;
    }
    /**
     * Determines whether the Object represented by the current Type is structurally compatible and assignable to the Object represented by the specified Type
     * @param {Type} target
     * @return {boolean}
     * @private
     */
    isStructurallyAssignableTo(target) {
        if (!this.isObjectLike() || !target.isObjectLike()) {
            return false;
        }
        const currentMembers = this.flattenInheritedMembers();
        const currentProperties = Object.values(currentMembers.properties);
        const currentMethods = Object.values(currentMembers.methods);
        const targetMembers = target.flattenInheritedMembers();
        const targetProperties = Object.values(targetMembers.properties);
        const targetMethods = Object.values(targetMembers.methods);
        // All the target properties are required (may be optional), so all of them must be present in current Type.. to be assignable
        return targetProperties.every(targetProperty => targetProperty.optional || currentProperties.some(currentProperty => currentProperty.name == targetProperty.name
            && currentProperty.type.isAssignableTo(targetProperty.type)))
            // same for methods. All targets methods must be present in current Type (methods are matched by name and parameters' types)
            && targetMethods.every(targetMethod => targetMethod.optional || currentMethods.some(currentMethod => {
                const currentMethodParameters = currentMethod.getParameters();
                return currentMethod.name == targetMethod.name
                    && targetMethod.getParameters().every((targetMethodParam, i) => {
                        const currentMethodParam = currentMethodParameters[i];
                        if (currentMethodParam == undefined) {
                            return targetMethodParam.optional;
                        }
                        return currentMethodParam.type.isAssignableTo(targetMethodParam.type);
                    });
            }));
    }
    /**
     * Determines whether an instance of the current Type can be assigned to an instance of the specified Type.
     * @description This is fulfilled by derived types or compatible types.
     * @param target
     */
    isAssignableTo(target) {
        var _a, _b;
        if (this.isAny() || target.isAny()) {
            return true;
        }
        if ((this.isTrue() || this.isFalse()) && target.isBoolean()) {
            return true;
        }
        // TODO: Literals. "foo".isAssignableTo(string), 5.isAssignableTo(number)
        // Container types check
        if (this.kind == enums_1.TypeKind.Container || target.kind == enums_1.TypeKind.Container) {
            // target type is not container but source is => not assignable
            if (target.kind != enums_1.TypeKind.Container) {
                return false;
            }
            // Source is not container, but it can be subtype
            if (this.kind != enums_1.TypeKind.Container) {
                return ((_a = target.types) === null || _a === void 0 ? void 0 : _a.some(targetType => this.isAssignableTo(targetType))) || false;
            }
            // -- both types are container
            // containers' types do not match (union vs intersection)
            if (!(this.isUnion() == target.isUnion() && this.isIntersection() == target.isIntersection())) {
                return false;
            }
            return ((_b = this.types) === null || _b === void 0 ? void 0 : _b.every(thisType => { var _a; return (_a = target.types) === null || _a === void 0 ? void 0 : _a.some(targetType => thisType.isAssignableTo(targetType)); })) || false;
        }
        // Both must be array or not
        if (this.isArray() != target.isArray()) {
            return false;
        }
        // It is array. Type of array must match.
        if (this.isArray()) {
            return this.getTypeArguments()[0].isDerivedFrom(target.getTypeArguments()[0])
                // anonymous type check
                || this.isStructurallyAssignableTo(target.getTypeArguments()[0])
                || false;
        }
        return this.isDerivedFrom(target)
            // anonymous type check
            || this.isStructurallyAssignableTo(target)
            || false;
    }
    /**
     * Returns string representation of the type.
     */
    toString() {
        return `{${enums_1.TypeKind[this.kind]} ${this.name} (${this.fullName})}`;
    }
}
exports.Type = Type;
/** @internal */
Type._store = {
    store: {},
    get(id) {
        return undefined;
    },
    set(id, description) {
        return Type.Unknown;
    },
    getLazy(id) {
        return () => undefined;
    },
    wrap(description) {
        return Type.Unknown;
    }
};
/**
 * @internal
 */
class TypeActivator extends Type {
}
exports.TypeActivator = TypeActivator;
