"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InjectRepository = void 0;
const typeorm_1 = require("typeorm");
const typedi_1 = require("typedi");
const entity_type_missing_error_1 = require("../errors/entity-type-missing.error");
const property_type_missing_error_1 = require("../errors/property-type-missing.error");
const param_type_missing_error_1 = require("../errors/param-type-missing.error");
const manager_not_found_error_1 = require("../errors/manager-not-found.error");
/**
 * Helper to avoid V8 compilation of anonymous function on each call of decorator.
 */
function getRepositoryHelper(connectionName, repositoryType, entityType, containerInstance) {
    const connectionManager = containerInstance.get(typeorm_1.ConnectionManager);
    if (!connectionManager.has(connectionName)) {
        throw new manager_not_found_error_1.ConnectionNotFoundError(connectionName);
    }
    const connection = connectionManager.get(connectionName);
    switch (repositoryType) {
        case typeorm_1.Repository:
            return connection.getRepository(entityType);
        case typeorm_1.MongoRepository:
            return connection.getMongoRepository(entityType);
        case typeorm_1.TreeRepository:
            return connection.getTreeRepository(entityType);
        default:
            /** If the requested type is not well-known, then it must be a custom repository. */
            return connection.getCustomRepository(repositoryType);
    }
}
function InjectRepository(entityTypeOrConnectionName, paramConnectionName = 'default') {
    return (object, propertyName, index) => {
        let entityType;
        let connectionName;
        let repositoryType;
        // handle first parameter overload
        connectionName = paramConnectionName;
        if (typeof entityTypeOrConnectionName === 'string') {
            connectionName = entityTypeOrConnectionName;
        }
        else if (typeof entityTypeOrConnectionName === 'function') {
            entityType = entityTypeOrConnectionName;
        }
        if ((Reflect === null || Reflect === void 0 ? void 0 : Reflect.getOwnMetadata) == undefined) {
            throw new Error('Reflect.getOwnMetadata is not defined. Make sure to import the `reflect-metadata` package!');
        }
        if (index !== undefined) {
            /** The decorator has been applied to a constructor parameter. */
            const paramTypes = Reflect.getOwnMetadata('design:paramtypes', object, propertyName);
            if (!paramTypes || !paramTypes[index]) {
                throw new param_type_missing_error_1.ParamTypeMissingError(object, propertyName, index);
            }
            repositoryType = paramTypes[index];
        }
        else {
            /** The decorator has been applied to a class property. */
            const propertyType = Reflect.getOwnMetadata('design:type', object, propertyName);
            if (!propertyType) {
                throw new property_type_missing_error_1.PropertyTypeMissingError(object, propertyName);
            }
            repositoryType = propertyType;
        }
        switch (repositoryType) {
            case typeorm_1.Repository:
            case typeorm_1.MongoRepository:
            case typeorm_1.TreeRepository:
                if (!entityType) {
                    throw new entity_type_missing_error_1.EntityTypeMissingError(object, propertyName, index);
                }
        }
        typedi_1.Container.registerHandler({
            object: object,
            index: index,
            propertyName: propertyName,
            value: containerInstance => getRepositoryHelper(connectionName, repositoryType, entityType, containerInstance),
        });
    };
}
exports.InjectRepository = InjectRepository;
//# sourceMappingURL=inject-repository.decorator.js.map